import { resolve } from "node:path";
import { Case } from "change-case-all";
import type { OpenAPIV3_1 } from "openapi-types";
import {
  getRequestBody,
  getResponse,
  getSortedSchemas,
  iterParams,
  iterPathConfig,
  responseSchema,
} from "./base";
import { fileWriter } from "./io";
import { collectReferencedSchemas } from "./resolver";
import { schemaToTypes } from "./schema";
import {
  docComment,
  extractDoc,
  pathToTemplateStr,
  queryParamsType,
  responseType,
} from "./util";

/**
 * Generates a resource file for a given API tag.
 * Creates type definitions and a resource class with methods for each operation.
 */
export async function generateResource(
  tag: OpenAPIV3_1.TagObject,
  spec: OpenAPIV3_1.Document<{
    "x-codegen": {
      method_name?: string;
    };
  }>,
  destDir: string,
) {
  const outFile = resolve(
    destDir,
    "resources",
    Case.kebab(tag.name),
    "index.ts",
  );
  const writer = fileWriter(outFile);

  const exports: string[] = [];

  writer.w(`
// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.

import * as Core from '../../core';
    `);

  const resourceSchemas = collectReferencedSchemas(spec, tag.name);
  const schemaNames = getSortedSchemas(spec);

  for (const schemaName of schemaNames) {
    if (!resourceSchemas.has(`#/components/schemas/${schemaName}`)) {
      continue;
    }

    const schema = spec.components!.schemas![schemaName];
    // Special case for Error type for two reasons:
    //   1) Error is already a thing in JS, so we rename to ErrorBody. This
    //      rename only works because no other types refer to this one
    //   2) We hard-code the definition of `ErrorBody` in http-client.ts, so we
    //      want to skip writing it here
    if (schemaName === "Error") {
      continue;
    }

    if ("description" in schema || "title" in schema) {
      const comment = docComment(extractDoc(schema));
      if (comment) {
        writer.w(comment);
      }
    }

    writer.w(`export type ${schemaName} =`);
    schemaToTypes(schema, writer);
    writer.w(";\n");

    exports.push(schemaName);
  }

  for (const { methodSpec, queryParams, opId } of iterParams(spec.paths)) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const opName = Case.pascal(opId);

    // Request body
    const body = getRequestBody(opId, methodSpec);
    if (body && !("$ref" in body.schema)) {
      writer.w0(`export type ${body.typeName} = `);
      schemaToTypes(body.schema, writer);
      writer.w("\n");
      exports.push(body.typeName);
    }

    // Query params
    if (queryParams.length > 0) {
      writer.w(`export type ${queryParamsType(opName)} = {`);
      for (const param of queryParams) {
        if ("description" in param.schema || "title" in param.schema) {
          const comment = docComment(extractDoc(param.schema));
          if (comment) {
            writer.w(comment);
          }
        }

        writer.w(`  '${param.name}'`);
        if (!param.required) writer.w0("?");
        writer.w0(": ");
        schemaToTypes(param.schema, writer);
        writer.w(",");
      }
      writer.w("}\n");
      exports.push(queryParamsType(opName));
    }

    // Response
    const successResponse =
      methodSpec.responses["200"] ||
      methodSpec.responses["201"] ||
      methodSpec.responses["202"] ||
      methodSpec.responses["204"];

    const resp = responseSchema(successResponse);
    if (resp && !("$ref" in resp)) {
      writer.w0(`export type ${responseType(opName)} = `);
      schemaToTypes(resp, writer);
      writer.w("\n");
    }
  }

  const resourceName = Case.pascal(tag.name);
  writer.w(`
export class ${resourceName} extends Core.APIResource {`);
  for (const { methodSpec, pathSpec, opId, method, path } of iterPathConfig(
    spec.paths,
  )) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const nameOverride =
      "x-codegen" in methodSpec &&
      // biome-ignore lint/suspicious/noExplicitAny: OpenAPI extension type is dynamic
      (methodSpec["x-codegen"] as any)?.method_name;

    const methodName = Case.camel(nameOverride || opId);
    const methodNameType = Case.pascal(opId);

    const params = (pathSpec.parameters || []).concat(
      methodSpec.parameters || [],
    );
    const pathParams = params.filter(
      (p) => "in" in p && p.in === "path",
    ) as OpenAPIV3_1.ParameterObject[];
    const queryParams = params.filter(
      (p) => "in" in p && p.in === "query",
    ) as OpenAPIV3_1.ParameterObject[];

    const successResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => code.startsWith("2"))
      .map(([, resp]) => getResponse(methodNameType, resp));

    const successType = successResponses.join(" | ");

    const comment = docComment(methodSpec.description || methodSpec.summary);
    if (comment) {
      writer.w(comment);
    }

    writer.w0(`${methodName}(`);

    if (pathParams.length > 0) {
      for (const param of pathParams) {
        writer.w0(Case.camel(param.name));
        writer.w0(": ");
        schemaToTypes(param.schema!, writer);
        writer.w0(", ");
      }
    }

    const body = getRequestBody(opId, methodSpec);
    if (body) {
      writer.w0(`body${body.required ? "" : "?"}: ${body.typeName}, `);
    }

    if (queryParams.length > 0) {
      writer.w0("query");
      if (!queryParams.some((p) => p.required)) writer.w0("?");
      writer.w0(`: ${queryParamsType(methodNameType)}, `);
    }

    writer.w(`params?: Core.FetchParams): Core.APIPromise<${successType || "void"}> {
         return this._client.${method}<${successType || "void"}>({
           path: ${pathToTemplateStr(path)},`);
    if (methodSpec.requestBody) {
      writer.w("  body,");
    }
    if (queryParams.length > 0) {
      writer.w("  query,");
    }
    writer.w(`  ...params,
         })
      }\n`);
  }
  writer.w("}");
  writer.w("");
  writer.w(`export declare namespace ${resourceName} {`);
  writer.w("export type {");
  for (const s of exports.sort()) {
    writer.w(`${s}, `);
  }
  writer.w("}");
  writer.w("}");

  await writer.flush();
}

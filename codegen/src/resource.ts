import { resolve } from "node:path";
import { Case } from "change-case-all";
import type { OpenAPIV3_1 } from "openapi-types";
import {
  getRequestBody,
  getResponse,
  getSortedSchemas,
  iterParams,
  iterPathConfig,
  responseSchema,
} from "./base";
import { fileWriter } from "./io";
import { collectReferencedSchemas } from "./resolver";
import { schemaToTypes } from "./schema";
import {
  docComment,
  errorType,
  extractDoc,
  pathToTemplateStr,
  queryParamsType,
  responseType,
} from "./util";

/**
 * Generates a resource file for a given API tag.
 * Creates type definitions and a resource class with methods for each operation.
 */
export async function generateResource(
  tag: OpenAPIV3_1.TagObject,
  spec: OpenAPIV3_1.Document<{
    "x-codegen": {
      method_name?: string;
    };
  }>,
  destDir: string,
) {
  const outFile = resolve(
    destDir,
    "resources",
    Case.kebab(tag.name),
    "index.ts",
  );
  const writer = fileWriter(outFile);

  const exports: string[] = [];
  const unique = (types: (string | null)[]) => [
    ...new Set(types.filter(Boolean)),
  ];
  const resolveResponseObject = (
    response: OpenAPIV3_1.ResponseObject | OpenAPIV3_1.ReferenceObject,
  ) => {
    if (!("$ref" in response)) {
      return response;
    }

    const prefix = "#/components/responses/";
    if (!response.$ref.startsWith(prefix)) {
      return null;
    }

    const responseName = response.$ref.slice(prefix.length);
    const resolvedResponse = spec.components?.responses?.[responseName];
    if (!resolvedResponse || "$ref" in resolvedResponse) {
      return null;
    }

    return resolvedResponse;
  };

  writer.w(`
// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.

import * as Core from '../../core';
    `);

  const resourceSchemas = collectReferencedSchemas(spec, tag.name);
  const schemaNames = getSortedSchemas(spec);

  for (const schemaName of schemaNames) {
    if (!resourceSchemas.has(`#/components/schemas/${schemaName}`)) {
      continue;
    }

    const schema = spec.components!.schemas![schemaName];
    // Special case for Error type for two reasons:
    //   1) Error is already a thing in JS, so we rename to ErrorBody. This
    //      rename only works because no other types refer to this one
    //   2) We hard-code the definition of `ErrorBody` in http-client.ts, so we
    //      want to skip writing it here
    if (schemaName === "Error") {
      continue;
    }

    if ("description" in schema || "title" in schema) {
      const comment = docComment(extractDoc(schema));
      if (comment) {
        writer.w(comment);
      }
    }

    writer.w(`export type ${schemaName} =`);
    schemaToTypes(schema, writer);
    writer.w(";\n");

    exports.push(schemaName);
  }

  for (const { methodSpec, queryParams, opId } of iterParams(spec.paths)) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const opName = Case.pascal(opId);

    // Request body
    const body = getRequestBody(opId, methodSpec);
    if (body && !("$ref" in body.schema)) {
      writer.w0(`export type ${body.typeName} = `);
      schemaToTypes(body.schema, writer);
      writer.w("\n");
      exports.push(body.typeName);
    }

    // Query params
    if (queryParams.length > 0) {
      writer.w(`export type ${queryParamsType(opName)} = {`);
      for (const param of queryParams) {
        if ("description" in param.schema || "title" in param.schema) {
          const comment = docComment(extractDoc(param.schema));
          if (comment) {
            writer.w(comment);
          }
        }

        writer.w(`  '${param.name}'`);
        if (!param.required) writer.w0("?");
        writer.w0(": ");
        schemaToTypes(param.schema, writer);
        writer.w(",");
      }
      writer.w("}\n");
      exports.push(queryParamsType(opName));
    }

    // Response
    const successResponse =
      methodSpec.responses["200"] ||
      methodSpec.responses["201"] ||
      methodSpec.responses["202"] ||
      methodSpec.responses["204"];

    const resp = responseSchema(
      successResponse
        ? resolveResponseObject(successResponse) || successResponse
        : successResponse,
    );
    if (resp && !("$ref" in resp)) {
      writer.w0(`export type ${responseType(opName)} = `);
      schemaToTypes(resp, writer);
      writer.w("\n");
      exports.push(responseType(opName));
    }

    const errorResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, resp]) => resolveResponseObject(resp) || resp)
      .map((resp) => responseSchema(resp))
      .filter(
        (resp): resp is OpenAPIV3_1.SchemaObject => !!resp && !("$ref" in resp),
      );

    if (errorResponses.length > 0) {
      writer.w0(`export type ${errorType(opName)} = `);
      for (const [index, errorResponse] of errorResponses.entries()) {
        if (index > 0) {
          writer.w0(" | ");
        }
        schemaToTypes(errorResponse, writer);
      }
      writer.w("\n");
      exports.push(errorType(opName));
    }
  }

  const resourceName = Case.pascal(tag.name);
  writer.w(`
export class ${resourceName} extends Core.APIResource {`);
  for (const { methodSpec, pathSpec, opId, method, path } of iterPathConfig(
    spec.paths,
  )) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const nameOverride =
      "x-codegen" in methodSpec &&
      // biome-ignore lint/suspicious/noExplicitAny: OpenAPI extension type is dynamic
      (methodSpec["x-codegen"] as any)?.method_name;

    const methodName = Case.camel(nameOverride || opId);
    const methodNameType = Case.pascal(opId);

    const params = (pathSpec.parameters || []).concat(
      methodSpec.parameters || [],
    );
    const pathParams = params.filter(
      (p) => "in" in p && p.in === "path",
    ) as OpenAPIV3_1.ParameterObject[];
    const queryParams = params.filter(
      (p) => "in" in p && p.in === "query",
    ) as OpenAPIV3_1.ParameterObject[];

    const successResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => code.startsWith("2"))
      .map(([, resp]) => resolveResponseObject(resp) || resp)
      .map((resp) => getResponse(methodNameType, resp));
    const errorResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, resp]) => resolveResponseObject(resp) || resp)
      .map((resp) =>
        getResponse(methodNameType, resp, errorType(methodNameType)),
      );

    const successTypes = unique(successResponses);
    const errorTypes = unique(errorResponses);
    const successType = successTypes.join(" | ") || "void";
    const errorTypeName = errorTypes.join(" | ") || "unknown";

    const comment = docComment(methodSpec.description || methodSpec.summary);
    if (comment) {
      writer.w(comment);
    }

    writer.w0(`${methodName}(`);

    if (pathParams.length > 0) {
      for (const param of pathParams) {
        writer.w0(Case.camel(param.name));
        writer.w0(": ");
        schemaToTypes(param.schema!, writer);
        writer.w0(", ");
      }
    }

    const body = getRequestBody(opId, methodSpec);
    if (body) {
      writer.w0(`body${body.required ? "" : "?"}: ${body.typeName}, `);
    }

    if (queryParams.length > 0) {
      writer.w0("query");
      if (!queryParams.some((p) => p.required)) writer.w0("?");
      writer.w0(`: ${queryParamsType(methodNameType)}, `);
    }

    writer.w(`params?: Core.FetchParams): Core.APIPromise<${successType}, ${errorTypeName}> {
         return this._client.${method}<${successType}, ${errorTypeName}>({
           path: ${pathToTemplateStr(path)},`);
    if (methodSpec.requestBody) {
      writer.w("  body,");
    }
    if (queryParams.length > 0) {
      writer.w("  query,");
    }
    writer.w(`  ...params,
         })
      }\n`);
  }
  writer.w("}");
  writer.w("");
  writer.w(`export declare namespace ${resourceName} {`);
  writer.w("export type {");
  for (const s of exports.sort()) {
    writer.w(`${s}, `);
  }
  writer.w("}");
  writer.w("}");

  await writer.flush();
}

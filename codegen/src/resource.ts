import { resolve } from "node:path";
import { Case } from "change-case-all";
import type { OpenAPIV3_1 } from "openapi-types";
import {
  getRequestBody,
  getResponse,
  getSortedSchemas,
  iterParams,
  iterPathConfig,
  responseSchema,
} from "./base";
import type { FileWriter } from "./io";
import { fileWriter } from "./io";
import { schemaNameToTypeName, schemaToTypes } from "./schema";
import {
  docComment,
  errorType,
  extractDoc,
  pathToTemplateStr,
  queryParamsType,
  responseType,
} from "./util";

/**
 * Generates a resource file for a given API tag.
 * Creates operation-specific type definitions and a resource class.
 */
export async function generateResource(
  tag: OpenAPIV3_1.TagObject,
  spec: OpenAPIV3_1.Document<{
    "x-codegen": {
      method_name?: string;
    };
  }>,
  destDir: string,
) {
  const outFile = resolve(
    destDir,
    "resources",
    Case.kebab(tag.name),
    "index.ts",
  );
  const writer = fileWriter(outFile);

  const schemaTypeNames = new Set(
    getSortedSchemas(spec).map((schemaName) =>
      schemaNameToTypeName(schemaName),
    ),
  );

  const resourceName = Case.pascal(tag.name);
  const resourceClassName = schemaTypeNames.has(resourceName)
    ? `${resourceName}Resource`
    : resourceName;

  const usedSharedTypes = new Set<string>();
  const addSharedType = (name: string) => {
    usedSharedTypes.add(name);
    return name;
  };

  const unique = (types: (string | null)[]) => [
    ...new Set(types.filter(Boolean)),
  ];

  const collectorWriter = {
    w() {},
    w0() {},
  } as unknown as FileWriter;

  const resolveResponseObject = (
    response: OpenAPIV3_1.ResponseObject | OpenAPIV3_1.ReferenceObject,
  ) => {
    if (!("$ref" in response)) {
      return response;
    }

    const prefix = "#/components/responses/";
    if (!response.$ref.startsWith(prefix)) {
      return null;
    }

    const responseName = response.$ref.slice(prefix.length);
    const resolvedResponse = spec.components?.responses?.[responseName];
    if (!resolvedResponse || "$ref" in resolvedResponse) {
      return null;
    }

    return resolvedResponse;
  };

  // First pass: collect all shared schema types that are actually referenced.
  for (const { methodSpec, queryParams, opId, pathSpec } of iterParams(
    spec.paths,
  )) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const body = getRequestBody(opId, methodSpec);
    if (body) {
      if ("$ref" in body.schema) {
        addSharedType(body.typeName);
      } else {
        schemaToTypes(body.schema, collectorWriter, { onRef: addSharedType });
      }
    }

    for (const param of queryParams) {
      schemaToTypes(param.schema, collectorWriter, { onRef: addSharedType });
    }

    const successResponse =
      methodSpec.responses["200"] ||
      methodSpec.responses["201"] ||
      methodSpec.responses["202"] ||
      methodSpec.responses["204"];

    const successSchema = responseSchema(
      successResponse
        ? resolveResponseObject(successResponse) || successResponse
        : successResponse,
    );

    if (successSchema && !("$ref" in successSchema)) {
      schemaToTypes(successSchema, collectorWriter, { onRef: addSharedType });
    }

    const inlineErrorSchemas = Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) => responseSchema(response))
      .filter(
        (candidate): candidate is OpenAPIV3_1.SchemaObject =>
          !!candidate && !("$ref" in candidate),
      );

    for (const inlineErrorSchema of inlineErrorSchemas) {
      schemaToTypes(inlineErrorSchema, collectorWriter, {
        onRef: addSharedType,
      });
    }

    const methodNameType = Case.pascal(opId);
    const params = (pathSpec.parameters || []).concat(
      methodSpec.parameters || [],
    );
    const pathParams = params.filter(
      (p) => "in" in p && p.in === "path",
    ) as OpenAPIV3_1.ParameterObject[];

    for (const pathParam of pathParams) {
      schemaToTypes(pathParam.schema!, collectorWriter, {
        onRef: addSharedType,
      });
    }

    Object.entries(methodSpec.responses)
      .filter(([code]) => code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) =>
        getResponse(
          methodNameType,
          response,
          responseType(methodNameType),
          (name) => addSharedType(name),
        ),
      );

    Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) =>
        getResponse(
          methodNameType,
          response,
          errorType(methodNameType),
          (name) => addSharedType(name),
        ),
      );
  }

  writer.w(`
// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.

import { APIResource, type APIPromise, type FetchParams } from "../../core";
`);

  const sortedSharedTypes = [...usedSharedTypes].sort((a, b) =>
    a > b ? 1 : -1,
  );
  if (sortedSharedTypes.length > 0) {
    writer.w(
      `import type { ${sortedSharedTypes.join(", ")} } from "../../types";`,
    );
  }

  for (const { methodSpec, queryParams, opId } of iterParams(spec.paths)) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const opName = Case.pascal(opId);

    const body = getRequestBody(opId, methodSpec);
    if (body && !("$ref" in body.schema)) {
      writer.w0(`export type ${body.typeName} = `);
      schemaToTypes(body.schema, writer);
      writer.w("\n");
    }

    if (queryParams.length > 0) {
      writer.w(`export type ${queryParamsType(opName)} = {`);
      for (const param of queryParams) {
        if ("description" in param.schema || "title" in param.schema) {
          const comment = docComment(extractDoc(param.schema));
          if (comment) {
            writer.w(comment);
          }
        }

        writer.w(`  '${param.name}'`);
        if (!param.required) writer.w0("?");
        writer.w0(": ");
        schemaToTypes(param.schema, writer);
        writer.w(",");
      }
      writer.w("}\n");
    }

    const successResponse =
      methodSpec.responses["200"] ||
      methodSpec.responses["201"] ||
      methodSpec.responses["202"] ||
      methodSpec.responses["204"];

    const resp = responseSchema(
      successResponse
        ? resolveResponseObject(successResponse) || successResponse
        : successResponse,
    );
    if (resp && !("$ref" in resp)) {
      writer.w0(`export type ${responseType(opName)} = `);
      schemaToTypes(resp, writer);
      writer.w("\n");
    }

    const inlineErrorSchemas = Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) => responseSchema(response))
      .filter(
        (candidate): candidate is OpenAPIV3_1.SchemaObject =>
          !!candidate && !("$ref" in candidate),
      );

    if (inlineErrorSchemas.length > 0) {
      writer.w0(`export type ${errorType(opName)} = `);
      for (const [index, inlineErrorSchema] of inlineErrorSchemas.entries()) {
        if (index > 0) {
          writer.w0(" | ");
        }
        schemaToTypes(inlineErrorSchema, writer);
      }
      writer.w("\n");
    }
  }

  writer.w(`
export class ${resourceClassName} extends APIResource {`);
  for (const { methodSpec, pathSpec, opId, method, path } of iterPathConfig(
    spec.paths,
  )) {
    if (!methodSpec.tags?.includes(tag.name)) {
      continue;
    }

    const nameOverride =
      "x-codegen" in methodSpec &&
      // biome-ignore lint/suspicious/noExplicitAny: OpenAPI extension type is dynamic
      (methodSpec["x-codegen"] as any)?.method_name;

    const methodName = Case.camel(nameOverride || opId);
    const methodNameType = Case.pascal(opId);

    const params = (pathSpec.parameters || []).concat(
      methodSpec.parameters || [],
    );
    const pathParams = params.filter(
      (p) => "in" in p && p.in === "path",
    ) as OpenAPIV3_1.ParameterObject[];
    const queryParams = params.filter(
      (p) => "in" in p && p.in === "query",
    ) as OpenAPIV3_1.ParameterObject[];

    const successResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) =>
        getResponse(methodNameType, response, responseType(methodNameType)),
      );
    const errorResponses = Object.entries(methodSpec.responses)
      .filter(([code]) => !code.startsWith("2"))
      .map(([, response]) => resolveResponseObject(response) || response)
      .map((response) =>
        getResponse(methodNameType, response, errorType(methodNameType)),
      );

    const successTypes = unique(successResponses);
    const errorTypes = unique(errorResponses);
    const successType = successTypes.join(" | ") || "void";
    const errorTypeName = errorTypes.join(" | ") || "unknown";

    const comment = docComment(methodSpec.description || methodSpec.summary);
    if (comment) {
      writer.w(comment);
    }

    writer.w0(`${methodName}(`);

    if (pathParams.length > 0) {
      for (const param of pathParams) {
        writer.w0(Case.camel(param.name));
        writer.w0(": ");
        schemaToTypes(param.schema!, writer);
        writer.w0(", ");
      }
    }

    const body = getRequestBody(opId, methodSpec);
    if (body) {
      writer.w0(`body${body.required ? "" : "?"}: ${body.typeName}, `);
    }

    if (queryParams.length > 0) {
      writer.w0("query");
      if (!queryParams.some((param) => param.required)) writer.w0("?");
      writer.w0(`: ${queryParamsType(methodNameType)}, `);
    }

    writer.w(`params?: FetchParams): APIPromise<${successType}, ${errorTypeName}> {
         return this._client.${method}<${successType}, ${errorTypeName}>({
           path: ${pathToTemplateStr(path)},`);
    if (methodSpec.requestBody) {
      writer.w("  body,");
    }
    if (queryParams.length > 0) {
      writer.w("  query,");
    }
    writer.w(`  ...params,
         })
      }\n`);
  }
  writer.w("}");

  await writer.flush();
}

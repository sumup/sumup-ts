import { resolve } from "node:path";
import type { OpenAPIV3_1 } from "openapi-types";
import { fileWriter } from "./io";

/**
 * Generates the core.ts file containing base classes and types used by all resources.
 * This includes APIResource base class, error handling, and the custom APIPromise wrapper.
 */
export async function generateCore(
  spec: OpenAPIV3_1.Document,
  destDir: string,
) {
  if (!spec.components) return;

  const outFile = resolve(destDir, "core.ts");
  const writer = fileWriter(outFile);

  const apiName = "SumUp";
  writer.w(`
// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.

import type { ${apiName} } from './index';

export class APIResource {
  protected _client: ${apiName};

  constructor(client: ${apiName}) {
    this._client = client;
  }
}

// has to be any. the particular query params types don't like unknown
// biome-ignore lint/suspicious/noExplicitAny: any, but only for tests
type QueryParams = Record<string, any>;

/**
 * Params that get passed to \`fetch\`. This ends up as an optional second
 * argument to each generated request method. Properties are a subset of
 * \`RequestInit\`.
 */
export type FetchParams = Omit<RequestInit, "body" | "method">;

/** All arguments to \`request()\` */
export type FullParams = FetchParams & {
  path: string;
  query?: QueryParams;
  body?: unknown;
  host?: string;
  method?: string;
};

export class SumUpError extends Error {}

export class APIError<T> extends SumUpError {
  /* HTTP status for the response that caused the error */
  readonly status: number;
  /* JSON body of the response that caused the error */
  readonly error: T | string;
  /* Raw response of the API */
  readonly response: Response;

  constructor(status: number, error: T | string, response: Response) {
    const message = typeof error === "string" ? error : JSON.stringify(error);
    super(\`\${status}: \${message}\`);
    this.status = status;
    this.error = error;
    this.response = response;
  }
}

export class APIPromise<T> implements Promise<T> {
  constructor(private resp: Promise<Response>) {}

  async parse(): Promise<T> {
    const res = await this.resp;
    const contentType = res.headers.get("content-type");
    const isJSON = contentType?.includes("application/json");

    if (!isJSON) {
      throw new SumUpError("Unexpected non-json response.");
    }

    return await res.json();
  }

  async withResponse(): Promise<{ data: T; response: Response }> {
    const [data, response] = await Promise.all([this.parse(), await this.resp]);
    return { data, response };
  }

  // biome-ignore lint/suspicious/noThenProperty: custom promise to enable \`withResponse\`
  then<TResult1 = T, TResult2 = never>(
    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    // biome-ignore lint/suspicious/noExplicitAny: must satisfy promise interface
    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>,
  ): Promise<TResult1 | TResult2> {
    return this.parse().then(onFulfilled, onRejected);
  }

  catch<TResult = never>(
    // biome-ignore lint/suspicious/noExplicitAny: must satisfy promise interface
    onRejected?: (reason: any) => TResult | PromiseLike<TResult>,
  ): Promise<T | TResult> {
    return this.parse().catch(onRejected);
  }

  finally(onFinally?: () => void): Promise<T> {
    return this.parse().finally(onFinally);
  }

  [Symbol.toStringTag] = "APIPromise";
}
`);

  await writer.flush();
}

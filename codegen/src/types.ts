import { resolve } from "node:path";
import { Case } from "change-case-all";
import type { OpenAPIV3_1 } from "openapi-types";
import { getSortedSchemas } from "./base";
import { type FileWriter, fileWriter } from "./io";
import { schemaNameToTypeName, schemaToTypes } from "./schema";
import { docComment, extractDoc } from "./util";

const typeFileName = (typeName: string) => `${Case.kebab(typeName)}.ts`;

class BufferWriter {
  buf = "";

  w(str: string): void {
    this.buf += `${str}\n`;
  }

  w0(str: string): void {
    this.buf += str;
  }
}

const renderSchemaType = (schema: OpenAPIV3_1.SchemaObject) => {
  const refs = new Set<string>();
  const writer = new BufferWriter();
  schemaToTypes(schema, writer as unknown as FileWriter, {
    onRef: (typeName) => refs.add(typeName),
  });

  return {
    typeBody: writer.buf,
    refs: [...refs],
  };
};

/**
 * Generates the sdk/src/types folder with one file per component schema.
 */
export async function generateTypes(
  spec: OpenAPIV3_1.Document,
  destDir: string,
) {
  if (!spec.components?.schemas) {
    return;
  }

  const schemaNames = getSortedSchemas(spec);
  const typeNames = schemaNames.map((schemaName) =>
    schemaNameToTypeName(schemaName),
  );
  const typeToFile = new Map(
    typeNames.map((typeName) => [typeName, typeFileName(typeName)]),
  );

  for (const schemaName of schemaNames) {
    const schema = spec.components.schemas[schemaName];
    if (!schema || "$ref" in schema) {
      continue;
    }

    const typeName = schemaNameToTypeName(schemaName);
    const outFile = resolve(destDir, "types", typeFileName(typeName));
    const writer = fileWriter(outFile);

    const { typeBody, refs: rawRefs } = renderSchemaType(schema);
    const refs = rawRefs
      .filter((refTypeName) => refTypeName !== typeName)
      .filter((refTypeName) => typeToFile.has(refTypeName))
      .sort((a, b) => (a > b ? 1 : -1));

    writer.w(`// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.\n`);

    for (const refTypeName of refs) {
      const fileName = typeToFile.get(refTypeName);
      if (!fileName) {
        continue;
      }
      const importPath = `./${fileName.replace(/\.ts$/, "")}`;
      writer.w(`import type { ${refTypeName} } from "${importPath}";`);
    }
    if (refs.length > 0) {
      writer.w("");
    }

    if ("description" in schema || "title" in schema) {
      const comment = docComment(extractDoc(schema));
      if (comment) {
        writer.w(comment);
      }
    }

    writer.w(`export type ${typeName} =`);
    writer.w0(typeBody);
    writer.w(";");

    await writer.flush();
  }

  const indexWriter = fileWriter(resolve(destDir, "types", "index.ts"));
  indexWriter.w(`// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.\n`);
  for (const typeName of [...typeNames].sort((a, b) => (a > b ? 1 : -1))) {
    const fileName = typeToFile.get(typeName)!;
    const importPath = `./${fileName.replace(/\.ts$/, "")}`;
    indexWriter.w(`export type { ${typeName} } from "${importPath}";`);
  }
  await indexWriter.flush();
}

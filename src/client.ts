// Code generated by `ts-sdk-gen`. Edit to customize your HTTP client.

import * as Core from "./core";

export const VERSION = "0.0.1-beta.4"; // x-release-please-version

export type APIConfig = {
  apiKey?: string;
  baseParams?: Core.FetchParams;
  host?: string;
};

export class HTTPClient {
  host: string;
  apiKey?: string;
  baseParams: Core.FetchParams;

  constructor({
    apiKey,
    host = "https://api.sumup.com",
    baseParams = {},
  }: APIConfig = {}) {
    this.host = host;
    this.apiKey = apiKey;

    const headers = new Headers({
      "Accept": "application/json",
      "Content-Type": "application/json",
      "User-Agent": `${this.constructor.name.toLowerCase()}-ts/${VERSION}`,
    });
    if (apiKey) {
      headers.append("Authorization", `Bearer ${apiKey}`);
    }
    this.baseParams = mergeParams({ headers }, baseParams);
  }

  public get<R, E = Core.APIError<unknown>>({
    ...params
  }: Omit<Core.FullParams, "method">): Core.APIPromise<R> {
    return this.request<R, E>({
      method: "GET",
      ...params,
    });
  }

  public post<R, E = Core.APIError<unknown>>({
    ...params
  }: Omit<Core.FullParams, "method">): Core.APIPromise<R> {
    return this.request<R, E>({
      method: "POST",
      ...params,
    });
  }

  public put<R, E = Core.APIError<unknown>>({
    ...params
  }: Omit<Core.FullParams, "method">): Core.APIPromise<R> {
    return this.request<R, E>({
      method: "put",
      ...params,
    });
  }

  public patch<R, E = Core.APIError<unknown>>({
    ...params
  }: Omit<Core.FullParams, "method">): Core.APIPromise<R> {
    return this.request<R, E>({
      method: "PATCH",
      ...params,
    });
  }

  public delete<R, E = Core.APIError<unknown>>({
    ...params
  }: Omit<Core.FullParams, "method">): Core.APIPromise<R> {
    return this.request<R, E>({
      method: "DELETE",
      ...params,
    });
  }

  public request<T, E = Core.APIError<unknown>>({
    body,
    path,
    query,
    host: hostOverride,
    ...fetchParams
  }: Core.FullParams): Core.APIPromise<T> {
    const host = hostOverride || this.host;
    const url = new URL(
      host +
        (host.endsWith("/") && path.startsWith("/") ? path.slice(1) : path),
    );
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query as Record<string, unknown>);
    }
    const init = {
      ...mergeParams(this.baseParams, fetchParams),
      body: JSON.stringify(body),
    };
    return new Core.APIPromise<T>(this.do<E>(url, init));
  }

  protected async do<E>(input: URL, init: RequestInit): Promise<Response> {
    const res = await fetch(input, init);

    if (!res.ok) {
      const contentType = res.headers.get("content-type");
      const isJSON = contentType?.includes("application/json");
      throw new Core.APIError(
        res.status,
        isJSON ? ((await res.json()) as E) : await res.text(),
        res,
      );
    }

    return res;
  }

  protected stringifyQuery(query: Record<string, unknown>): string {
    return Object.entries(query)
      .filter(([_, value]) => typeof value !== "undefined")
      .map(([key, value]) => {
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean"
        ) {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        if (Array.isArray(value)) {
          return value
            .map((v) => `${encodeURIComponent(key)}=${encodeURIComponent(v)}`)
            .join("&");
        }
        throw new Error(
          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null.`,
        );
      })
      .join("&");
  }
}

export function mergeParams(
  a: Core.FetchParams,
  b: Core.FetchParams,
): Core.FetchParams {
  // calling `new Headers()` normalizes `HeadersInit`, which could be a Headers
  // object, a plain object, or an array of tuples
  const headers = new Headers(a.headers);
  for (const [key, value] of new Headers(b.headers).entries()) {
    headers.set(key, value);
  }
  return { ...a, ...b, headers };
}

// Code generated by @sumup/ts-sdk-gen@0.0.1. DO NOT EDIT.

import type { SumUp } from "./index";

export class APIResource {
  protected _client: SumUp;

  constructor(client: SumUp) {
    this._client = client;
  }
}

// has to be any. the particular query params types don't like unknown
// biome-ignore lint/suspicious/noExplicitAny: any, but only for tests
type QueryParams = Record<string, any>;

/**
 * Params that get passed to `fetch`. This ends up as an optional second
 * argument to each generated request method. Properties are a subset of
 * `RequestInit`.
 */
export type FetchParams = Omit<RequestInit, "body" | "method">;

/** All arguments to `request()` */
export type FullParams = FetchParams & {
  path: string;
  query?: QueryParams;
  body?: unknown;
  host?: string;
  method?: string;
};

export class SumUpError extends Error {}

export class APIError<T> extends SumUpError {
  /* HTTP status for the response that caused the error */
  readonly status: number;
  /* JSON body of the response that caused the error */
  readonly error: T | string;
  /* Raw response of the API */
  readonly response: Response;

  constructor(status: number, error: T | string, response: Response) {
    const message = typeof error === "string" ? error : JSON.stringify(error);
    super(`${status}: ${message}`);
    this.status = status;
    this.error = error;
    this.response = response;
  }
}

export class APIPromise<T> implements Promise<T> {
  constructor(private resp: Promise<Response>) {}

  async parse(): Promise<T> {
    const res = await this.resp;
    const contentType = res.headers.get("content-type");
    const isJSON = contentType?.includes("application/json");

    if (!isJSON) {
      throw new SumUpError("Unexpected non-json response.");
    }

    return await res.json();
  }

  async withResponse(): Promise<{ data: T; response: Response }> {
    const [data, response] = await Promise.all([this.parse(), await this.resp]);
    return { data, response };
  }

  // biome-ignore lint/suspicious/noThenProperty: custom promise to enable `withResponse`
  then<TResult1 = T, TResult2 = never>(
    onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,
    // biome-ignore lint/suspicious/noExplicitAny: must satisfy promise interface
    onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>,
  ): Promise<TResult1 | TResult2> {
    return this.parse().then(onFulfilled, onRejected);
  }

  catch<TResult = never>(
    // biome-ignore lint/suspicious/noExplicitAny: must satisfy promise interface
    onRejected?: (reason: any) => TResult | PromiseLike<TResult>,
  ): Promise<T | TResult> {
    return this.parse().catch(onRejected);
  }

  finally(onFinally?: () => void): Promise<T> {
    return this.parse().finally(onFinally);
  }

  [Symbol.toStringTag] = "APIPromise";
}

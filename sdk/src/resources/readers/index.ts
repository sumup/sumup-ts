// Code generated by @sumup/sumup-ts-codegen. DO NOT EDIT.

import { type APIPromise, APIResource, type FetchParams } from "../../core";

import type {
  BadGateway,
  BadRequest,
  CreateReaderCheckoutError,
  CreateReaderCheckoutRequest,
  CreateReaderCheckoutResponse,
  CreateReaderCheckoutUnprocessableEntity,
  CreateReaderTerminateError,
  CreateReaderTerminateUnprocessableEntity,
  GatewayTimeout,
  InternalServerError,
  Metadata,
  NotFound,
  Problem,
  Reader,
  ReaderID,
  ReaderName,
  ReaderPairingCode,
  StatusResponse,
  Unauthorized,
} from "../../types";
export type ListReadersResponse = { items: Reader[] };

export type CreateReaderParams = {
  pairing_code: ReaderPairingCode;
  name: ReaderName;
  metadata?: Metadata;
};

export type UpdateReaderParams = { name?: ReaderName; metadata?: Metadata };

export type CreateReaderTerminateParams = Record<string, unknown>;

export class Readers extends APIResource {
  /**
   * List all readers of the merchant.
   */
  list(
    merchantCode: string,
    params?: FetchParams,
  ): APIPromise<ListReadersResponse, unknown> {
    return this._client.get<ListReadersResponse, unknown>({
      path: `/v0.1/merchants/${merchantCode}/readers`,
      ...params,
    });
  }

  /**
   * Create a new Reader for the merchant account.
   */
  create(
    merchantCode: string,
    body: CreateReaderParams,
    params?: FetchParams,
  ): APIPromise<Reader, Problem> {
    return this._client.post<Reader, Problem>({
      path: `/v0.1/merchants/${merchantCode}/readers`,
      body,
      ...params,
    });
  }

  /**
   * Retrieve a Reader.
   */
  get(
    merchantCode: string,
    id: ReaderID,
    params?: FetchParams,
  ): APIPromise<Reader, Problem> {
    return this._client.get<Reader, Problem>({
      path: `/v0.1/merchants/${merchantCode}/readers/${id}`,
      ...params,
    });
  }

  /**
   * Delete a reader.
   */
  delete(
    merchantCode: string,
    id: ReaderID,
    params?: FetchParams,
  ): APIPromise<void, Problem> {
    return this._client.delete<void, Problem>({
      path: `/v0.1/merchants/${merchantCode}/readers/${id}`,
      ...params,
    });
  }

  /**
   * Update a Reader.
   */
  update(
    merchantCode: string,
    id: ReaderID,
    body: UpdateReaderParams,
    params?: FetchParams,
  ): APIPromise<Reader, Problem> {
    return this._client.patch<Reader, Problem>({
      path: `/v0.1/merchants/${merchantCode}/readers/${id}`,
      body,
      ...params,
    });
  }

  /**
   * Creates a Checkout for a Reader.
   *
   * This process is asynchronous and the actual transaction may take some time to be stared on the device.
   *
   *
   * There are some caveats when using this endpoint:
   * * The target device must be online, otherwise checkout won't be accepted
   * * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected.
   *
   *
   * **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.
   *
   */
  createCheckout(
    merchantCode: string,
    readerId: string,
    body: CreateReaderCheckoutRequest,
    params?: FetchParams,
  ): APIPromise<
    CreateReaderCheckoutResponse,
    CreateReaderCheckoutError | CreateReaderCheckoutUnprocessableEntity
  > {
    return this._client.post<
      CreateReaderCheckoutResponse,
      CreateReaderCheckoutError | CreateReaderCheckoutUnprocessableEntity
    >({
      path: `/v0.1/merchants/${merchantCode}/readers/${readerId}/checkout`,
      body,
      ...params,
    });
  }

  /**
   * Provides the last known status for a Reader.
   *
   * This endpoint allows you to retrieve updates from the connected card reader, including the current screen being displayed during the payment process and the device status (battery level, connectivity, and update state).
   *
   * Supported States
   *
   * * `IDLE` – Reader ready for next transaction
   * * `SELECTING_TIP` – Waiting for tip input
   * * `WAITING_FOR_CARD` – Awaiting card insert/tap
   * * `WAITING_FOR_PIN` – Waiting for PIN entry
   * * `WAITING_FOR_SIGNATURE` – Waiting for customer signature
   * * `UPDATING_FIRMWARE` – Firmware update in progress
   *
   * Device Status
   *
   * * `ONLINE` – Device connected and operational
   * * `OFFLINE` – Device disconnected (last state persisted)
   *
   * **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.
   *
   */
  getStatus(
    merchantCode: string,
    readerId: string,
    params?: FetchParams,
  ): APIPromise<
    StatusResponse,
    | BadRequest
    | Unauthorized
    | NotFound
    | InternalServerError
    | BadGateway
    | GatewayTimeout
  > {
    return this._client.get<
      StatusResponse,
      | BadRequest
      | Unauthorized
      | NotFound
      | InternalServerError
      | BadGateway
      | GatewayTimeout
    >({
      path: `/v0.1/merchants/${merchantCode}/readers/${readerId}/status`,
      ...params,
    });
  }

  /**
   * Terminate a Reader Checkout stops the current transaction on the target device.
   *
   * This process is asynchronous and the actual termination may take some time to be performed on the device.
   *
   *
   * There are some caveats when using this endpoint:
   * * The target device must be online, otherwise terminate won't be accepted
   * * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc.
   * * There is no confirmation of the termination.
   *
   * If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL.
   *
   *
   * **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.
   *
   */
  terminateCheckout(
    merchantCode: string,
    readerId: string,
    body?: CreateReaderTerminateParams,
    params?: FetchParams,
  ): APIPromise<
    void,
    CreateReaderTerminateError | CreateReaderTerminateUnprocessableEntity
  > {
    return this._client.post<
      void,
      CreateReaderTerminateError | CreateReaderTerminateUnprocessableEntity
    >({
      path: `/v0.1/merchants/${merchantCode}/readers/${readerId}/terminate`,
      body,
      ...params,
    });
  }
}
